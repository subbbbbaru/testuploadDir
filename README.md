Простой Python-проект

Допустим, у вас есть простой проект на Python с файлом app.py, содержащим код:

# app.py
```python
from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello_world():
    return 'Hello, World!'

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=80)
```

И файл requirements.txt с зависимостью:
```
flask==2.0.1
```

Теперь рассмотрим два подхода сборки образа Docker: без многоступенчатой сборки и с многоступенчатой сборкой.


Сборка Docker-образа без многоступенчатых этапов (Dockerfile)

Этот вариант собирает образ, включив в него все файлы и зависимости сразу в одном этапе.
```Dockerfile
FROM python:3.12-slim-buster AS base

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["python", "app.py"]
```

Что здесь происходит?

Мы используем базовый образ Python версии 3.12 на основе (легкий дистрибутив).
Создаем рабочую директорию /app.
Копируем файл требований (requirements.txt) внутрь контейнера и устанавливаем необходимые пакеты.
Затем копируем весь исходный код нашего проекта в контейнер.
Запускаем приложение.


Многоступенчатая сборка (Dockerfile-multistage)

Здесь мы разделяем процесс сборки на две части: одна стадия для установки зависимостей, вторая — для развертывания готового приложения.
```Dockerfile
# Этап 1: Установка зависимостей
FROM python:3.12-slim-buster AS builder

WORKDIR /build
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Этап 2: Создание финального образа
FROM python:3.12-slim-buster AS final

WORKDIR /app
COPY --from=builder /usr/local/lib/python3.12/site-packages /usr/local/lib/python3.12/site-packages
COPY . .

CMD ["python", "app.py"]
```
Что здесь происходит?

Первая стадия (builder) устанавливает зависимости в отдельной среде.
Вторая стадия (final) берет чистый базовый образ Python и копирует установленные зависимости из первой стадии.
Далее мы добавляем сам исходный код проекта и настраиваем запуск приложения.


Преимущества многоступенчатой сборки:

Размер итогового образа значительно меньше, поскольку промежуточные этапы сборки удаляются.
Повышается безопасность, так как промежуточные артефакты не попадают в конечный образ.
Уменьшаются временные затраты на повторные сборки, если изменения касаются только основного кода, а не зависимостей.

Таким образом, многоступенчатая сборка предпочтительнее для большинства проектов, особенно если важно оптимизировать размер образов и повысить производительность CI/CD-процессов.
